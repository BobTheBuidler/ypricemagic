

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>y._db.common &mdash; ypricemagic  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ypricemagic
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../source/modules.html">y</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ypricemagic</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">y._db.common</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for y._db.common</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">asyncio</span> <span class="kn">import</span> <span class="n">Task</span><span class="p">,</span> <span class="n">create_task</span><span class="p">,</span> <span class="n">get_event_loop</span><span class="p">,</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">dropwhile</span><span class="p">,</span> <span class="n">groupby</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="kn">import</span> <span class="n">DEBUG</span><span class="p">,</span> <span class="n">getLogger</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">AsyncIterator</span><span class="p">,</span>
    <span class="n">Awaitable</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Container</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">NoReturn</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">a_sync</span>
<span class="kn">import</span> <span class="nn">dank_mids</span>
<span class="kn">import</span> <span class="nn">eth_retry</span>
<span class="kn">from</span> <span class="nn">a_sync</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ASyncIterable</span><span class="p">,</span>
    <span class="n">ASyncIterator</span><span class="p">,</span>
    <span class="n">AsyncThreadPoolExecutor</span><span class="p">,</span>
    <span class="n">CounterLock</span><span class="p">,</span>
    <span class="n">PruningThreadPoolExecutor</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">async_property</span> <span class="kn">import</span> <span class="n">async_property</span>
<span class="kn">from</span> <span class="nn">brownie</span> <span class="kn">import</span> <span class="n">ZERO_ADDRESS</span>
<span class="kn">from</span> <span class="nn">dank_mids</span> <span class="kn">import</span> <span class="n">BlockSemaphore</span>
<span class="kn">from</span> <span class="nn">evmspec.data</span> <span class="kn">import</span> <span class="n">Address</span><span class="p">,</span> <span class="n">HexBytes32</span>
<span class="kn">from</span> <span class="nn">hexbytes</span> <span class="kn">import</span> <span class="n">HexBytes</span>
<span class="kn">from</span> <span class="nn">pony.orm</span> <span class="kn">import</span> <span class="n">OptimisticCheckError</span><span class="p">,</span> <span class="n">TransactionIntegrityError</span><span class="p">,</span> <span class="n">db_session</span>
<span class="kn">from</span> <span class="nn">web3.datastructures</span> <span class="kn">import</span> <span class="n">AttributeDict</span>
<span class="kn">from</span> <span class="nn">web3.middleware.filter</span> <span class="kn">import</span> <span class="n">block_ranges</span>

<span class="kn">from</span> <span class="nn">y</span> <span class="kn">import</span> <span class="n">convert</span>
<span class="kn">from</span> <span class="nn">y</span> <span class="kn">import</span> <span class="n">ENVIRONMENT_VARIABLES</span> <span class="k">as</span> <span class="n">ENVS</span>
<span class="kn">from</span> <span class="nn">y._db.decorators</span> <span class="kn">import</span> <span class="n">retry_locked</span>
<span class="kn">from</span> <span class="nn">y._db.exceptions</span> <span class="kn">import</span> <span class="n">CacheNotPopulatedError</span>
<span class="kn">from</span> <span class="nn">y._decorators</span> <span class="kn">import</span> <span class="n">stuck_coro_debugger</span>
<span class="kn">from</span> <span class="nn">y.exceptions</span> <span class="kn">import</span> <span class="n">reraise_excs_with_extra_context</span>
<span class="kn">from</span> <span class="nn">y.utils.middleware</span> <span class="kn">import</span> <span class="n">BATCH_SIZE</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">y</span> <span class="kn">import</span> <span class="n">Block</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">)</span>

<span class="n">Checkpoints</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">default_filter_threads</span> <span class="o">=</span> <span class="n">PruningThreadPoolExecutor</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The thread pool executor used for all :class:`Filter` objects without one provided, with a maximum of 4 threads.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">enc_hook</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encode hook for JSON serialization of special types.</span>

<span class="sd">    Args:</span>
<span class="sd">        obj: The object to encode.</span>

<span class="sd">    Raises:</span>
<span class="sd">        NotImplementedError: If the object type is not supported for encoding.</span>

<span class="sd">    Note:</span>
<span class="sd">        Currently supports encoding of :class:`int`, :class:`Address`, :class:`HexBytes32`, :class:`HexBytes`, and :class:`AttributeDict` objects.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from web3.datastructures import AttributeDict</span>
<span class="sd">        &gt;&gt;&gt; enc_hook(AttributeDict({&#39;key&#39;: &#39;value&#39;}))</span>
<span class="sd">        {&#39;key&#39;: &#39;value&#39;}</span>

<span class="sd">        &gt;&gt;&gt; from hexbytes import HexBytes</span>
<span class="sd">        &gt;&gt;&gt; enc_hook(HexBytes(&#39;0x1234&#39;))</span>
<span class="sd">        &#39;1234&#39;</span>

<span class="sd">    See Also:</span>
<span class="sd">        - :func:`dec_hook`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="c1"># sometimes we get a recursion error from the instance checks, this helps us debug that case.</span>
    <span class="k">with</span> <span class="n">reraise_excs_with_extra_context</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">typ</span><span class="p">):</span>
        <span class="c1"># we use issubclass instead of isinstance here to prevent a recursion error</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">Address</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">HexBytes32</span><span class="p">):</span>
            <span class="c1"># we trim all leading zeroes since we know how many we need to put back later</span>
            <span class="k">return</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">hex</span><span class="p">(),</span> <span class="mi">16</span><span class="p">))[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">HexBytes</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">AttributeDict</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>


<span class="k">def</span> <span class="nf">dec_hook</span><span class="p">(</span><span class="n">typ</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decode hook for JSON deserialization of special types.</span>

<span class="sd">    Args:</span>
<span class="sd">        typ: The type to decode into.</span>
<span class="sd">        obj: The object to decode.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the type is not supported for decoding.</span>

<span class="sd">    Note:</span>
<span class="sd">        Currently only supports decoding of :class:`HexBytes` objects.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from hexbytes import HexBytes</span>
<span class="sd">        &gt;&gt;&gt; dec_hook(HexBytes, b&#39;1234&#39;)</span>
<span class="sd">        HexBytes(&#39;0x1234&#39;)</span>

<span class="sd">    See Also:</span>
<span class="sd">        - :func:`enc_hook`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">typ</span> <span class="ow">is</span> <span class="n">HexBytes</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">typ</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">typ</span><span class="si">}</span><span class="s2"> is not a valid type for decoding&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">DiskCache</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">S</span><span class="p">,</span> <span class="n">M</span><span class="p">],</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_set_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update cache metadata to indicate that the cache is populated from block `from_block` to block `done_thru`.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: The starting block number.</span>
<span class="sd">            done_thru: The ending block number indicating that the cache is populated up to this block.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; disk_cache._set_metadata(100, 200)</span>

<span class="sd">        See Also:</span>
<span class="sd">            - :meth:`set_metadata`</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_is_cached_thru</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Block&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns max cached block for this cache or 0 if not cached.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: The starting block number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The maximum cached block number.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">to_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">S</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Selects all cached objects from block `from_block` to block `to_block`.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: The starting block number.</span>
<span class="sd">            to_block: The ending block number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of cached objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@retry_locked</span>
    <span class="k">def</span> <span class="nf">set_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update cache metadata to indicate that the cache is populated from block `from_block` to block `done_thru`.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: The starting block number.</span>
<span class="sd">            done_thru: The ending block number up to which the cache is populated.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cache.set_metadata(100, 200)</span>

<span class="sd">        See Also:</span>
<span class="sd">            - :meth:`_set_metadata`</span>
<span class="sd">            - :class:`CacheNotPopulatedError`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">db_session</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_metadata</span><span class="p">(</span><span class="n">from_block</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">TransactionIntegrityError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> got exc </span><span class="si">%s</span><span class="s2"> when setting cache metadata&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_metadata</span><span class="p">(</span><span class="n">from_block</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">OptimisticCheckError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Don&#39;t need to update in this case</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> got exc </span><span class="si">%s</span><span class="s2"> when setting cache metadata&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

    <span class="nd">@db_session</span>
    <span class="nd">@retry_locked</span>
    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">to_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">S</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Selects all cached objects from block `from_block` to block `to_block`.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: The starting block number.</span>
<span class="sd">            to_block: The ending block number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of cached objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select</span><span class="p">(</span><span class="n">from_block</span><span class="p">,</span> <span class="n">to_block</span><span class="p">)</span>

    <span class="nd">@db_session</span>
    <span class="nd">@retry_locked</span>
    <span class="k">def</span> <span class="nf">is_cached_thru</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Block&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns max cached block for this cache or 0 if not cached.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: The starting block number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The maximum cached block number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_cached_thru</span><span class="p">(</span><span class="n">from_block</span><span class="p">)</span>

    <span class="nd">@db_session</span>
    <span class="nd">@retry_locked</span>
    <span class="k">def</span> <span class="nf">check_and_select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">to_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">S</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Selects all cached objects within a specified block range.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: The starting block number.</span>
<span class="sd">            to_block: The ending block number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of cached objects.</span>

<span class="sd">        Raises:</span>
<span class="sd">            CacheNotPopulatedError: If the cache is not fully populated.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; try:</span>
<span class="sd">            ...     data = cache.check_and_select(100, 200)</span>
<span class="sd">            ... except CacheNotPopulatedError:</span>
<span class="sd">            ...     print(&quot;Cache incomplete&quot;)</span>

<span class="sd">        See Also:</span>
<span class="sd">            - :meth:`set_metadata`</span>
<span class="sd">            - :meth:`select`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_cached_thru</span><span class="p">(</span><span class="n">from_block</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">to_block</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">from_block</span><span class="p">,</span> <span class="n">to_block</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">CacheNotPopulatedError</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">,</span> <span class="n">to_block</span><span class="p">)</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[]</span>


<span class="n">C</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">DiskCache</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DiskCachedMixin</span><span class="p">(</span><span class="n">ASyncIterable</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">],</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin that provides asynchronous features for data caches stored on disk.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_checkpoints</span><span class="p">:</span> <span class="n">Checkpoints</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="s2">&quot;is_reusable&quot;</span><span class="p">,</span> <span class="s2">&quot;_cache&quot;</span><span class="p">,</span> <span class="s2">&quot;_executor&quot;</span><span class="p">,</span> <span class="s2">&quot;_objects&quot;</span><span class="p">,</span> <span class="s2">&quot;_pruned&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">executor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AsyncThreadPoolExecutor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_reusable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the mixin.</span>

<span class="sd">        Args:</span>
<span class="sd">            executor: Optional executor to use for I/O operations.</span>
<span class="sd">            is_reusable: Whether data should be kept in memory for reuse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_reusable</span> <span class="o">=</span> <span class="n">is_reusable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="n">executor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pruned</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">C</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the associated cache object, which must be defined in subclasses.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">executor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncThreadPoolExecutor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the executor used for disk operations, creating one if necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">executor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span>
        <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">executor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="n">AsyncThreadPoolExecutor</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">executor</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shutdown the executor on deletion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">executor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span>
        <span class="k">if</span> <span class="n">executor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">executor</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">insert_to_db</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="kc">None</span><span class="p">]:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">bulk_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]],</span> <span class="n">Awaitable</span><span class="p">[</span><span class="kc">None</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to bulk insert a list of objects into the database.</span>

<span class="sd">        This property must be overridden in subclasses to provide the desired bulk insertion logic.</span>
<span class="sd">        The implementation should return a callable that accepts a list of objects (List[T])</span>
<span class="sd">        and returns an awaitable.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; async def my_bulk_insert(objs):</span>
<span class="sd">            ...     # perform custom bulk insert operations here</span>
<span class="sd">            ...     pass</span>
<span class="sd">            &gt;&gt;&gt; class MyFilter(_DiskCachedMixin):</span>
<span class="sd">            ...     @property</span>
<span class="sd">            ...     def bulk_insert(self) -&gt; Callable[[List[T]], Awaitable[None]]:</span>
<span class="sd">            ...         return my_bulk_insert</span>

<span class="sd">        See Also:</span>
<span class="sd">            - :meth:`_load_cache`</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objs</span><span class="p">:</span> <span class="n">Container</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override this to pre-process objects before storing.</span>

<span class="sd">        Args:</span>
<span class="sd">            objs (&quot;Container[T]&quot;): The objects to extend the list with.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; await instance._extend([obj1, obj2])</span>

<span class="sd">        See Also:</span>
<span class="sd">            - :meth:`_load_cache`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">objs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reusable</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_for_obj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_checkpoints</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_load_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Block&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads cached logs from disk.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: The starting block number.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The maximum block number loaded from cache, or None if no cached data is available.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; cached_thru = await instance._load_cache(100)</span>
<span class="sd">            &gt;&gt;&gt; if cached_thru is None:</span>
<span class="sd">            ...     print(&quot;No cached data available&quot;)</span>
<span class="sd">            ... else:</span>
<span class="sd">            ...     print(f&quot;Cache loaded through block {cached_thru}&quot;)</span>

<span class="sd">        See Also:</span>
<span class="sd">            - :meth:`_extend`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;checking to see if </span><span class="si">%s</span><span class="s2"> is cached in local db&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cached_thru</span> <span class="o">:=</span> <span class="k">await</span> <span class="n">_metadata_read_executor</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">is_cached_thru</span><span class="p">,</span> <span class="n">from_block</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is cached thru block </span><span class="si">%s</span><span class="s2">, loading from db&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">cached_thru</span><span class="p">)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend</span><span class="p">(</span><span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">executor</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">select</span><span class="p">,</span> <span class="n">from_block</span><span class="p">,</span> <span class="n">cached_thru</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reusable</span><span class="p">:</span>
                <span class="n">objs_per_chunk</span> <span class="o">=</span> <span class="mi">50</span>
                <span class="n">num_checkpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">)</span> <span class="o">//</span> <span class="n">objs_per_chunk</span>
                <span class="n">checkpoint_indexes</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">objs_per_chunk</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_checkpoints</span><span class="p">))</span>
                <span class="n">get_block_for_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_for_obj</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">checkpoint_indexes</span><span class="p">:</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">):</span>
                        <span class="n">next_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">while</span> <span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">next_obj</span><span class="p">):</span>
                            <span class="n">obj</span> <span class="o">=</span> <span class="n">next_obj</span>
                            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">next_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                                <span class="k">break</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_checkpoints</span><span class="p">[</span><span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">index</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> loaded </span><span class="si">%s</span><span class="s2"> objects thru block </span><span class="si">%s</span><span class="s2"> from disk&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">),</span>
                <span class="n">cached_thru</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">cached_thru</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span> <span class="nf">make_executor</span><span class="p">(</span><span class="n">small</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">big</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PruningThreadPoolExecutor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a thread pool executor that prunes completed tasks.</span>

<span class="sd">    Args:</span>
<span class="sd">        small: Size of the pool if using a non-postgres DB.</span>
<span class="sd">        big: Size of the pool if using a postgres DB.</span>
<span class="sd">        name: Optional name for the executor.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A PruningThreadPoolExecutor instance based on the environment configuration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">PruningThreadPoolExecutor</span><span class="p">(</span><span class="n">big</span> <span class="k">if</span> <span class="n">ENVS</span><span class="o">.</span><span class="n">DB_PROVIDER</span> <span class="o">==</span> <span class="s2">&quot;postgres&quot;</span> <span class="k">else</span> <span class="n">small</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<span class="n">_E</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_E&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">AsyncThreadPoolExecutor</span><span class="p">)</span>
<span class="n">_MAX_LONG_LONG</span> <span class="o">=</span> <span class="mi">9223372036854775807</span>

<span class="n">_metadata_read_executor</span> <span class="o">=</span> <span class="n">make_executor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;ypricemagic Filter read metadata&quot;</span><span class="p">)</span>
<span class="n">_metadata_write_executor</span> <span class="o">=</span> <span class="n">make_executor</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;ypricemagic Filter write metadata&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Filter</span><span class="p">(</span><span class="n">_DiskCachedMixin</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">C</span><span class="p">]):</span>
    <span class="c1"># defaults are stored as class vars to keep instance dicts smaller</span>
    <span class="n">_chunk_size</span> <span class="o">=</span> <span class="n">BATCH_SIZE</span>
    <span class="n">_chunks_per_batch</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_exc</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_tb</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_db_task</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_sleep_fut</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_sleep_time</span> <span class="o">=</span> <span class="mi">60</span>
    <span class="n">_task</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_depth</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">_semaphore</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;from_block&quot;</span><span class="p">,</span>
        <span class="s2">&quot;to_block&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_checkpoints&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_interval&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_lock&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">BATCH_SIZE</span><span class="p">,</span>
        <span class="n">chunks_per_batch</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sleep_time</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
        <span class="n">semaphore</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BlockSemaphore</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">executor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AsyncThreadPoolExecutor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_reusable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the Filter, specifying blocks, concurrency, and caching parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: Earliest block from which data should be retrieved.</span>
<span class="sd">            chunk_size: Size of each chunk to retrieve in a single RPC call.</span>
<span class="sd">            chunks_per_batch: How many chunks to load per batch (optional).</span>
<span class="sd">            sleep_time: Time (in seconds) to sleep between reloads when following chain head.</span>
<span class="sd">            semaphore: Block-based semaphore to limit concurrency.</span>
<span class="sd">            executor: Executor for disk-related tasks.</span>
<span class="sd">            is_reusable: Keeps data in memory if True; data is pruned when False.</span>
<span class="sd">            verbose: Enable debug-like progress logging if True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_block</span> <span class="o">=</span> <span class="n">from_block</span>
        <span class="k">if</span> <span class="n">chunk_size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span> <span class="o">=</span> <span class="n">chunk_size</span>
        <span class="k">if</span> <span class="n">chunks_per_batch</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunks_per_batch</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_chunks_per_batch</span> <span class="o">=</span> <span class="n">chunks_per_batch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span> <span class="o">=</span> <span class="n">CounterLock</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">semaphore</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semaphore</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_semaphore</span> <span class="o">=</span> <span class="n">semaphore</span>
        <span class="k">if</span> <span class="n">sleep_time</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_time</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_time</span> <span class="o">=</span> <span class="n">sleep_time</span>
        <span class="k">if</span> <span class="n">verbose</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_checkpoints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">executor</span><span class="o">=</span><span class="n">executor</span><span class="p">,</span> <span class="n">is_reusable</span><span class="o">=</span><span class="n">is_reusable</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__aiter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an async iterator over the stored objects, yielding new ones as they are fetched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects_thru</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="fm">__aiter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cancels any pending fetch task upon deletion.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_fetch_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">to_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches data for a given range of blocks from an on-chain or remote provider.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: Lower bound of the block range.</span>
<span class="sd">            to_block: Upper bound of the block range.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of objects for that block range.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">semaphore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockSemaphore</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semaphore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_semaphore</span> <span class="o">=</span> <span class="n">BlockSemaphore</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_chunks_per_batch</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semaphore</span>

    <span class="k">def</span> <span class="nf">_get_block_for_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Block&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override this as needed for different object types.</span>

<span class="sd">        Args:</span>
<span class="sd">            obj: The object to get the block number for.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The block number of the object.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; block = instance._get_block_for_obj(some_obj)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">blockNumber</span>

    <span class="nd">@ASyncIterator</span><span class="o">.</span><span class="n">wrap</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_objects_thru</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Block&quot;</span><span class="p">],</span> <span class="n">from_block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Block&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncIterator</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates objects up to a specified block, or indefinitely if none is given.</span>

<span class="sd">        Args:</span>
<span class="sd">            block: Maximum block number to generate objects. If None, yields continuously.</span>
<span class="sd">            from_block: Minimum block from which to start yielding objects. Only valid if reusable.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Objects that fall within the requested block range, if any.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_task</span><span class="p">()</span>
        <span class="n">debug_logs</span> <span class="o">=</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="n">yielded</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pruned</span>
        <span class="n">done_thru</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">get_block_for_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_for_obj</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reusable</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">from_block</span><span class="p">:</span>
                <span class="n">reached_from_block</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">def</span> <span class="nf">obj_out_of_range</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">from_block</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>
                    <span class="k">nonlocal</span> <span class="n">reached_from_block</span>
                    <span class="n">reached_from_block</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="k">def</span> <span class="nf">skip_too_early</span><span class="p">(</span><span class="n">objects</span><span class="p">):</span>
                    <span class="k">nonlocal</span> <span class="n">yielded</span>
                    <span class="k">if</span> <span class="n">checkpoints</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkpoints</span><span class="p">:</span>
                        <span class="n">start_checkpoint_index</span> <span class="o">=</span> <span class="n">_get_checkpoint_index</span><span class="p">(</span><span class="n">from_block</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">start_checkpoint_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">objects</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">start_checkpoint_index</span><span class="p">:]</span>
                            <span class="n">yielded</span> <span class="o">+=</span> <span class="n">start_checkpoint_index</span>
                    <span class="n">start_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
                    <span class="n">objects</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dropwhile</span><span class="p">(</span><span class="n">obj_out_of_range</span><span class="p">,</span> <span class="n">objects</span><span class="p">))</span>
                    <span class="n">yielded</span> <span class="o">+=</span> <span class="n">start_len</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">objects</span>

            <span class="k">if</span> <span class="n">objs</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">from_block</span><span class="p">:</span>
                        <span class="n">objs</span> <span class="o">=</span> <span class="n">skip_too_early</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">obj</span>
                    <span class="n">yielded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
                    <span class="n">done_thru</span> <span class="o">=</span> <span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkpoints</span><span class="p">:</span>
                    <span class="n">checkpoint_index</span> <span class="o">=</span> <span class="n">_get_checkpoint_index</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_checkpoints</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">checkpoint_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">objs</span> <span class="o">=</span> <span class="n">objs</span><span class="p">[:</span><span class="n">checkpoint_index</span><span class="p">]</span>
                        <span class="n">done_thru</span> <span class="o">=</span> <span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">objs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">from_block</span><span class="p">:</span>
                            <span class="n">objs</span> <span class="o">=</span> <span class="n">skip_too_early</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">obj</span>
                        <span class="n">yielded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">from_block</span><span class="p">:</span>
                    <span class="n">skip_too_early</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">from_block</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;You cannot pass a value for `from_block` unless the </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is reusable&quot;</span>
            <span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">done_thru</span> <span class="o">&lt;</span> <span class="n">block</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wakeup</span><span class="p">()</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">done_thru</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># raise a copy of it so multiple waiters don&#39;t destroy the traceback</span>
                <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exc</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tb</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">self._exc.__cause__</span>
            <span class="k">if</span> <span class="n">to_yield</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">yielded</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pruned</span> <span class="p">:]:</span>
                <span class="k">if</span> <span class="n">from_block</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reached_from_block</span><span class="p">:</span>
                    <span class="n">objs</span> <span class="o">=</span> <span class="n">skip_too_early</span><span class="p">(</span><span class="n">to_yield</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">obj</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">block</span><span class="p">:</span>
                                <span class="k">return</span>
                            <span class="k">yield</span> <span class="n">obj</span>
                    <span class="n">yielded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">block</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reusable</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_yield</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">block</span><span class="p">:</span>
                                <span class="k">return</span>
                            <span class="k">yield</span> <span class="n">obj</span>
                        <span class="n">yielded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_yield</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_yield</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">get_block_for_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">block</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">(</span><span class="n">yielded</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pruned</span><span class="p">)</span>
                                <span class="k">return</span>
                            <span class="k">yield</span> <span class="n">obj</span>
                            <span class="n">yielded</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">to_yield</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">obj</span>
                    <span class="n">yielded</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_yield</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_reusable</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_prune</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">to_yield</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">block</span> <span class="ow">and</span> <span class="n">done_thru</span> <span class="o">&gt;=</span> <span class="n">block</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="n">done_thru</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="n">debug_logs</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
                    <span class="n">DEBUG</span><span class="p">,</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> lock value </span><span class="si">%s</span><span class="s2"> to_block </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sleep_time</span><span class="p">)</span>

    <span class="nd">@async_property</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_sleep</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Puts the Filter into a sleep state until `_wakeup` is called. No new requests will be made.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_fut</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_fut</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_fut</span> <span class="o">=</span> <span class="n">get_event_loop</span><span class="p">()</span><span class="o">.</span><span class="n">create_future</span><span class="p">()</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_fut</span>

    <span class="k">def</span> <span class="nf">_wakeup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wake up the Filter to query logs from blocks not yet loaded into memory.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_fut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_fut</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep_fut</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Main coroutine that continuously runs the internal fetch loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fetch</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">traceback</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_exc</span> <span class="o">=</span> <span class="n">e</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tb</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">__traceback__</span>
            <span class="c1"># no need to hold vars in memory</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">_MAX_LONG_LONG</span><span class="p">)</span>
            <span class="k">raise</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines the main logic for populating the Filter with data. Subclasses can override if needed.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; await instance._fetch()</span>

<span class="sd">        See Also:</span>
<span class="sd">            - :meth:`_loop`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">from_block</span><span class="p">)</span>

    <span class="nd">@stuck_coro_debugger</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_fetch_range_wrapped</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">range_start</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">range_end</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">debug_logs</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps the _fetch_range call with concurrency control.</span>

<span class="sd">        Args:</span>
<span class="sd">            i: Index of the chunk or range segment.</span>
<span class="sd">            range_start: Lower bound of this block range.</span>
<span class="sd">            range_end: Upper bound of this block range.</span>
<span class="sd">            debug_logs: Whether debug logging is enabled.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple containing the index, the ending block, and the fetched objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">async</span> <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">semaphore</span><span class="p">[</span><span class="n">range_end</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">debug_logs</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
                    <span class="n">DEBUG</span><span class="p">,</span>
                    <span class="s2">&quot;fetching </span><span class="si">%s</span><span class="s2"> block </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">range_end</span><span class="p">,</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fetch_range</span><span class="p">(</span><span class="n">range_start</span><span class="p">,</span> <span class="n">range_end</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Work loop that continually fetches new data, loads from cache if available, then sleeps.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: Earliest block from which to begin loading data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;starting work loop for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cached_thru</span> <span class="o">:=</span> <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_cache</span><span class="p">(</span><span class="n">from_block</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">cached_thru</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_new_objects</span><span class="p">(</span><span class="n">start_from_block</span><span class="o">=</span><span class="n">cached_thru</span> <span class="ow">or</span> <span class="n">from_block</span><span class="p">)</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sleep</span>

    <span class="nd">@eth_retry</span><span class="o">.</span><span class="n">auto_retry</span>
    <span class="nd">@stuck_coro_debugger</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_load_new_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">to_block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Block&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">start_from_block</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Block&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Asynchronously loads new objects from your RPC, up to an optionally-specified end block.</span>

<span class="sd">        Args:</span>
<span class="sd">            to_block: Specific block to stop at. If None, load up to the current chain head.</span>
<span class="sd">            start_from_block: Block to start from if no prior data is cached.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">SLEEP_TIME</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">debug_logs</span> <span class="o">:=</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">,</span> <span class="s2">&quot;loading new objects for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,))</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">else</span> <span class="n">start_from_block</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_block</span>
        <span class="k">if</span> <span class="n">to_block</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">to_block</span>
            <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;start </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2"> is bigger than end </span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">, can&#39;t do that&quot;</span><span class="p">)</span>

            <span class="k">while</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">current_block</span> <span class="o">:=</span> <span class="k">await</span> <span class="n">dank_mids</span><span class="o">.</span><span class="n">eth</span><span class="o">.</span><span class="n">block_number</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;You&#39;re trying to query a block range that has not fully completed:</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;range end: </span><span class="si">%s</span><span class="s2">  current block: </span><span class="si">%s</span><span class="s2">  Waiting 1s and trying again...&quot;</span><span class="p">,</span>
                    <span class="n">end</span><span class="p">,</span>
                    <span class="n">current_block</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">await</span> <span class="n">sleep</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">debug_logs</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">end</span> <span class="o">:=</span> <span class="k">await</span> <span class="n">dank_mids</span><span class="o">.</span><span class="n">eth</span><span class="o">.</span><span class="n">block_number</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
                    <span class="n">DEBUG</span><span class="p">,</span>
                    <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> start </span><span class="si">%s</span><span class="s2"> is greater than end </span><span class="si">%s</span><span class="s2">, sleeping...&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">await</span> <span class="n">sleep</span><span class="p">(</span><span class="n">SLEEP_TIME</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">end</span> <span class="o">:=</span> <span class="k">await</span> <span class="n">dank_mids</span><span class="o">.</span><span class="n">eth</span><span class="o">.</span><span class="n">block_number</span><span class="p">):</span>
                <span class="k">await</span> <span class="n">sleep</span><span class="p">(</span><span class="n">SLEEP_TIME</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="s2">&quot;One of the blocks specified in filter (fromBlock, toBlock or blockHash) cannot be found.&quot;</span>
                <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Your rpc might be out of sync, trying again...&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span>

    <span class="nd">@stuck_coro_debugger</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_load_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">to_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a particular block range in chunks, respecting concurrency limits.</span>

<span class="sd">        Args:</span>
<span class="sd">            from_block: Lower bound of the block range.</span>
<span class="sd">            to_block: Upper bound of the block range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">debug_logs</span> <span class="o">:=</span> <span class="n">logger</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">,</span> <span class="s2">&quot;loading block range </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">from_block</span><span class="p">,</span> <span class="n">to_block</span><span class="p">))</span>
        <span class="n">chunks_yielded</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">done</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">coros</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fetch_range_wrapped</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">debug_logs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">block_ranges</span><span class="p">(</span><span class="n">from_block</span><span class="p">,</span> <span class="n">to_block</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunk_size</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunks_per_batch</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_chunks_per_batch</span>
        <span class="p">]</span>
        <span class="k">async</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">objs</span> <span class="ow">in</span> <span class="n">a_sync</span><span class="o">.</span><span class="n">as_completed</span><span class="p">(</span><span class="n">coros</span><span class="p">,</span> <span class="nb">aiter</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tqdm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_verbose</span><span class="p">):</span>
            <span class="n">next_chunk_loaded</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">done</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span> <span class="n">objs</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chunks_yielded</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coros</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">done</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">end</span><span class="p">,</span> <span class="n">objs</span> <span class="o">=</span> <span class="n">done</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_insert_chunk</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">from_block</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">debug_logs</span><span class="p">)</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
                <span class="n">next_chunk_loaded</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">chunks_yielded</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">next_chunk_loaded</span><span class="p">:</span>
                <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_lock</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">debug_logs</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="n">DEBUG</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> loaded thru block </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>

    <span class="nd">@stuck_coro_debugger</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_set_lock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override this if you want to, for things like awaiting for tasks to complete as I do in the curve module.</span>

<span class="sd">        Args:</span>
<span class="sd">            block: The block number to set the lock to.</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; await instance._set_lock(150)</span>

<span class="sd">        See Also:</span>
<span class="sd">            - :meth:`_load_new_objects`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lock</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_insert_chunk</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">objs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">debug_logs</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queues the insertion of a chunk of objects into the database, and sets metadata.</span>

<span class="sd">        Args:</span>
<span class="sd">            objs: List of objects to be inserted.</span>
<span class="sd">            from_block: Earliest block in the current overall range.</span>
<span class="sd">            done_thru: Block number up to which this chunk completes.</span>
<span class="sd">            debug_logs: Whether debug logging is active.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prev_task</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_db_task</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev_task</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">prev_task</span><span class="o">.</span><span class="n">exception</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="n">prev_task</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_depth</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">insert_coro</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__insert_chunk</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">from_block</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">,</span> <span class="n">prev_task</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">debug_logs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug_logs</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
                <span class="n">DEBUG</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> queuing next db insert chunk </span><span class="si">%s</span><span class="s2"> thru block </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">create_task</span><span class="p">(</span>
                <span class="n">coro</span><span class="o">=</span><span class="n">insert_coro</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;_insert_chunk from </span><span class="si">{</span><span class="n">from_block</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">done_thru</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">create_task</span><span class="p">(</span><span class="n">insert_coro</span><span class="p">)</span>

        <span class="n">task</span><span class="o">.</span><span class="n">_depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_db_task</span> <span class="o">=</span> <span class="n">task</span>

    <span class="k">def</span> <span class="nf">_ensure_task</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures there is a main fetch task running in the background. If not, creates it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;creating task for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task</span> <span class="o">=</span> <span class="n">create_task</span><span class="p">(</span><span class="n">coro</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__fetch</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">.__fetch&quot;</span><span class="p">)</span>
            <span class="c1"># NOTE: The task does not return and will be cancelled when this object is</span>
            <span class="c1"># garbage collected so there is no need to log the &quot;destroy pending task&quot; message.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_task</span><span class="o">.</span><span class="n">_log_destroy_pending</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task</span><span class="o">.</span><span class="n">done</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">e</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_task</span><span class="o">.</span><span class="n">exception</span><span class="p">()):</span>
            <span class="c1"># copy the exc so the traceback doesn&#39;t get destroyed by other waiters</span>
            <span class="k">raise</span> <span class="n">copy</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">__traceback__</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e.__cause__</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">__insert_chunk</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">objs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">T</span><span class="p">],</span>
        <span class="n">from_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span>
        <span class="n">done_thru</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span>
        <span class="n">prev_chunk_task</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Task</span><span class="p">],</span>
        <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">debug_logs</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts the previously fetched chunk into the database, waits on prior tasks if needed.</span>

<span class="sd">        Args:</span>
<span class="sd">            objs: List of objects to insert.</span>
<span class="sd">            from_block: Earliest block for the entire fetch range.</span>
<span class="sd">            done_thru: Ending block for this chunk.</span>
<span class="sd">            prev_chunk_task: Task that inserted previous chunk, if any.</span>
<span class="sd">            depth: Relative ordering of this chunk within the entire fetch.</span>
<span class="sd">            debug_logs: Whether debug logs are active.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prev_chunk_task</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">prev_chunk_task</span>
        <span class="k">del</span> <span class="n">prev_chunk_task</span>

        <span class="k">if</span> <span class="n">objs</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="o">.</span><span class="n">bulk_insert</span><span class="p">(</span><span class="n">objs</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">objs</span>

        <span class="k">await</span> <span class="n">_metadata_write_executor</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">set_metadata</span><span class="p">,</span> <span class="n">from_block</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">debug_logs</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
                <span class="n">DEBUG</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> chunk </span><span class="si">%s</span><span class="s2"> thru block </span><span class="si">%s</span><span class="s2"> is now in db&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">done_thru</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prune</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a specified number of objects from the beginning of the in-memory list.</span>

<span class="sd">        Args:</span>
<span class="sd">            count: Number of objects to remove.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_objects</span><span class="p">[</span><span class="n">count</span><span class="p">:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pruned</span> <span class="o">+=</span> <span class="n">count</span>


<span class="k">def</span> <span class="nf">_clean_addresses</span><span class="p">(</span><span class="n">addresses</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts addresses into a standardized format, raising an error if the zero address is encountered.</span>

<span class="sd">    Args:</span>
<span class="sd">        addresses: Single or multiple addresses to clean.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Cleaned addresses in a consistent string format or a list of such strings.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the zero address is encountered or if input is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">addresses</span> <span class="o">==</span> <span class="n">ZERO_ADDRESS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot make a LogFilter for the zero address&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">addresses</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">addresses</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">convert</span><span class="o">.</span><span class="n">to_address</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">addresses</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ZERO_ADDRESS</span> <span class="ow">in</span> <span class="n">addresses</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot make a LogFilter for the zero address&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">convert</span><span class="o">.</span><span class="n">to_address</span><span class="p">,</span> <span class="n">addresses</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">convert</span><span class="o">.</span><span class="n">to_address</span><span class="p">(</span><span class="n">addresses</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_suitable_checkpoint</span><span class="p">(</span><span class="n">target_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">:</span> <span class="n">Checkpoints</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Block&quot;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds a suitable checkpoint block that is less than or equal to a target block.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_block: The block number used as a reference.</span>
<span class="sd">        checkpoints: Dictionary of block -&gt; index.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Most recent checkpoint block before or equal to the target block, or None if none exist.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">block_lt_checkpoint</span><span class="p">,</span> <span class="n">group</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">groupby</span><span class="p">(</span><span class="n">checkpoints</span><span class="p">,</span> <span class="n">target_block</span><span class="o">.</span><span class="fm">__lt__</span><span class="p">))</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">block_lt_checkpoint</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">group</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_checkpoint_index</span><span class="p">(</span><span class="n">target_block</span><span class="p">:</span> <span class="s2">&quot;Block&quot;</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">:</span> <span class="n">Checkpoints</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieves the index for a checkpoint that is less than or equal to a given block.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_block: The block number reference.</span>
<span class="sd">        checkpoints: Dictionary of block -&gt; index.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The index of the checkpoint, or None if no suitable checkpoint exists.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">checkpoint_block</span> <span class="o">=</span> <span class="n">_get_suitable_checkpoint</span><span class="p">(</span><span class="n">target_block</span><span class="p">,</span> <span class="n">checkpoints</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">checkpoint_block</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">checkpoints</span><span class="p">[</span><span class="n">checkpoint_block</span><span class="p">]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, BobTheBuidler.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>